# 四种智能指针

管理指针，避免忘记释放空间造成内存泄露

```c++
T* release(); //将内部指针设置为nullptr
void reset(T *ptr = nullptr);// 直接释放内部指针所指向的内存
```

`auto_ptr`

```c++
auto_ptr<std::string> p1 (new string ("hello")); 
auto_ptr<std::string> p2;
p2 = p1; //auto_ptr 不会报错.
```

p2剥夺p1的所有权，访问p1会造成内存崩溃

`unique_str`

同一时间内只有一个智能指针可以指向该对象，利于避免资源泄露。

若上例采用`unique_ptr`，则编译器认为非法，避免了p3不再指向有效数据的问题。

`shared_ptr` 强引用

`shared_ptr`实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。

可以通过成员函数`use_count()` 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用 release() 时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被释放。

`weak_ptr`

```c++
#include <memory>
#include <iostream>

struct A;
struct B;

struct A {
  std::shared_ptr<B> b_ptr;
  ~A() { std::cout << "A is deleted\n"; }
};

struct B {
  std::shared_ptr<A> a_ptr;
  ~B() { std::cout << "B is deleted\n"; }
};

int main() {
  {
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();
    a->b_ptr = b;
    b->a_ptr = a;
  }

  std::cout << "End of main\n";
}

```

可以将其中一个`shared_ptr`转换成`weak_ptr`。

# C++中内存分配情况

栈 由编译器管理分配和回收，存放局部变􏰁和函数参数。

堆 程序员管理 手动new malloc delete free

全局/静态存储区 初始化/未初始化区

常量存储区 字符串等

代码区

# C++中指针参数传递和引用参数传递

引用参数传递过程中，被调函数的形式参数也作为局部变􏰁在栈中开辟了内存空间，但是这时存放的是由主调函数 放进来的实参变量的地址。被调函数对形参(本体)的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量(根据别名找到主调函数中的本体)。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

引用参数传递。间接寻址操作到主调函数中的相关变量

符号表上，指针变量的地址就是指针本身的地址，因此指针可以改变其指向的对象，而引用的地址就是其引用的变量的地址，无法改变。

# Static

修饰局部变量，放到静态存储区，生命周期与程序相同，作用域不变！

用 static 对全局变量进行修饰改变了其作用域范围，由原来的整个工程可⻅变成 了本文件可⻅。

修饰函数与修饰全局变量类似，改变了作用域。

函数体内 static 变􏰁的作用范围为该函数体，不同于 auto 变􏰁，该变􏰁的内存只被分配一次，因此其值在下 次调用时仍维持上次的值;

在模块内的 static 全局变􏰁可以被模块内所用函数访问，但不能被模块外其它函数访问;
 在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内; 在类中的 static 成员变􏰁属于整个类所拥有，对类的所有对象只有一份拷⻉;

在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变 􏰁。